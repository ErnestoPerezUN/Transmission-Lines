import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
import matplotlib.pyplot as plt2

# THis code shows the propagation of a wave in a 2D grid with a conductor in the middle of the grid.
# The code uses the Finite-Difference Time-Domain (FDTD) method to simulate the wave propagation.
# This code was automatically generated by chatgpt, and it is not guaranteed to be correct.
# Minor modifications were made to the code to make it work.

# Constants
c0 = 299792458
mu0 = 4 * np.pi * 1e-7
eps0 = 1 / (mu0 * c0**2)

# Grid and simulation settings
Nx, Ny = 500, 200   # Number of grid points in x and y directions
length=100          # Length of the conductor in x direction
cond_height=30   # Height of the conductor in y direction
dx = dy = 1e0       # Spatial resolution (1 mm)
dt = 1 / (c0 * np.sqrt(2)) * dx
steps = 10000  # Number of time steps
source_type = 'step'  # Type of source (gaussian or step)
slope = 1
conductivity=1000

# Defining Fields arrays
Ez = np.zeros((Nx, Ny))
Hx = np.zeros((Nx, Ny - 1))
Hy = np.zeros((Nx - 1, Ny))

# Material parameters
eps_r = np.ones((Nx, Ny))
sigma = np.zeros((Nx, Ny))

# Define conductor region on the right
cond_start = Nx//2 
cond_start -=length
cond_end = cond_start+length

Emax=1
sigma[cond_start:cond_end, cond_height] = conductivity  # High conductivity
probe_point = (cond_start+50, cond_height) 
# Update coefficients
Ca = (1 - sigma * dt / (2 * eps0 * eps_r)) / (1 + sigma * dt / (2 * eps0 * eps_r))
Cb = (dt / (eps0 * eps_r)) / (1 + sigma * dt / (2 * eps0 * eps_r))
print('dt [ms]:', dt*1e3)
print('dx [mm]:', dx*1e3)
# Pulse location
source_x, source_y = cond_start,cond_height# Ny // 8

fig2, ax2 = plt.subplots()
im2 = ax2.imshow(sigma.T, cmap='RdBu', origin='lower', vmin=-0.2, vmax=0.2, animated=True)

# Set up the plot
fig, ax = plt.subplots()
im = ax.imshow(Ez.T, cmap='RdBu', origin='lower', vmin=-0.2, vmax=0.2, animated=True)
ax.set_title("2D FDTD: Ez Field with Conductor")
ax.set_xlabel("x")
ax.set_ylabel("y")

voltage_probe = []
def update(n):
    global Ez, Hx, Hy

    # Update magnetic fields
    Hx[:, :] -= dt / (mu0 * dy) * (Ez[:, 1:] - Ez[:, :-1])
    Hy[:, :] += dt / (mu0 * dx) * (Ez[1:, :] - Ez[:-1, :])

    # Update electric field (Ez) from curl of H
    Ez[1:-1, 1:-1] = (Ca[1:-1, 1:-1] * Ez[1:-1, 1:-1] +
                     Cb[1:-1, 1:-1] * (
                         (Hy[1:, 1:-1] - Hy[:-1, 1:-1]) / dx -
                         (Hx[1:-1, 1:] - Hx[1:-1, :-1]) / dy
                     ))

    # Inject a Gaussian pulse
    if source_type == 'gaussian':
        Ez[source_x, source_y] += Emax * np.exp(-0.5 * ((n - 30) / 6) ** 2)
    elif source_type == 'step':
        if n<=np.round(1/slope):
            Ez[source_x, source_y] += Emax*slope 
        else:
            Ez[source_x, source_y]=Emax
    voltage_probe.append(Ez[probe_point])
    im.set_array(Ez.T)
    return [im]

ani = FuncAnimation(fig, update, frames=steps, interval=1, blit=False)
plt.show()
plt2.figure()
plt2.plot(voltage_probe)
plt2.title(f"Ez (Voltage) at Probe Point {probe_point}")
plt2.xlabel("Time Step")
plt2.ylabel("Ez Field (V/m)")
plt2.grid(True)
plt2.show()
